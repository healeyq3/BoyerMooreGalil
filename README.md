The BoyerMooreGalil Repository contains two primary folders. The first is titled "Research," where I have uploaded the respective research papers, as well as my notes on the algorithm(s). The second folder is simply "src," where the code is housed. This ReadME file will focus on this latter folder.

Within the src folder there are four .java files. "Practice.java" can be ignored. The "CharacterComparator.java" file consists of the CharacterComparator class that the GaTech CS 1332 TAs wrote to enable direct comparisons between characters in the pattern and text. "BoyerMooreTetsts.java" contains JUnit tests for the Boyer Moore algorithm, as well as the Boyer Moore algorithm with Galil's twist. As I will detail below, because the Boyer Moore algorithm that I implemented uses both the bad character rule as well as the good suffix heuristic (the latter is not implemented in CS 1332) the tests that I copied from Homework 9 are not yet functional with my code. The character comparisons need to be adapted for when the good suffix heuristic allows for a larger shift than the bad character rule indicates.

"BoyerMoore.java" is the heart of this project. Within the BoyerMoore class there are two public methods: "BoyerMoore" and "BoyerMooreGalil." The first is an implementation of the Boyer Moore algorithm which uses both the bad character and good suffix heuristics. The second method is almost an exact replica of the former, except that it also has my current (incomplete) implementation of the Galil rule. I will now expand further on this last point.

There are two main facets of the Galil rule's implmentation. The first is determining whether or not a pattern is periodic. The second is adjusting the shift framework so that when a pattern P matches with text T we exploit P's periodicity to reduce the number of comparisons between P and T. I have found the pattern shift adjustment to be much easier to implement than obtaining the pattern's periodicty. While the code contains JavaDocs and commenting to explain the implementation, I will give a high level overview here as well.

Before we enter the outer comparison loop I initialize the variable "l" to be equal to 0. In the inner while loop, instead of the first condition being that the pattern counter, "j," needs to be >= 0 I now impose the condition j >= l. Of course the checks are identical at first, but this follows Galil's rule: we cannot skip any comparisons until we have both found a match and determined that the pattern is periodic. 
Moving to the first if statement after the inner while loop you will see that the conditions being checked differ from the BoyerMoore method above. We first check to see if "j" is less than "l," which of course upon the first iteration of the algorithm is equal to 0. I will extrapolate on the second check later, but for now I will just label it "the Galil check" (note that it is currently incomplete). If we pass both these conditions then we know that the T's index "s" is the start of a match with P and that P is periodic. We can therefore set "l" to be P.length() - period and shift "s" by the period. This follows Galil's specifications.
There are two more subcomponents of this overarching shift adjustment. Quickly note that the first "else if" check is the same as the default Boyer Moore match case. The code within the block will be run if T contains P and P is not periodic. Moving onto the else statement I want to emphasize the first inner if statement. This code is executed when three conditions have been met. The first two are simply that we have already found an instance of P within T, and P is periodic. The final condition is that since this full match, we have come across a character mismatch (recall that this character mismatch will be between P[x] and T[s + x] where x belongs to [k-m, m]). In the case of this occurrence, we must now reset our lower bound pattern index to once again be 0, as we can only exploit Galil's observation when we have found a full pattern.

I will now delve into the challenge I have run into while implementing this algorithm. It stems from this slight gap in mathematical logic. As the CS 1332 module on the Galil rule points out: If P is periodic then the m - 1 index of the failure table used in the KMP pattern matching algorithm gives the correct period, k, of P. Note, however, that we must know that P is periodic. The failure table does not make this check for us.
As an example, take T = "revararevyw" and P = "rev

NOTE: As I am typing this out I realize that perhaps the ftable would work, not even requiring some form of check. I am going to work through some examples and then update this ReadME file.
