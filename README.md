The BoyerMooreGalil Repository contains two primary folders. The first is titled "Research," where I have uploaded the respective research papers, as well as my notes on the algorithm(s). The second folder is simply "src," where the code is housed. This ReadME file will focus on this latter folder.

Within the src folder there are four .java files. "Practice.java" can be ignored. The "CharacterComparator.java" file consists of the CharacterComparator class that the GaTech CS 1332 TAs wrote to enable direct comparisons between characters in the pattern and text. "BoyerMooreTetsts.java" contains JUnit tests for the Boyer Moore algorithm, as well as the Boyer Moore algorithm with Galil's twist. As I will detail below, because the Boyer Moore algorithm that I implemented uses both the bad character rule as well as the good suffix heuristic (the latter is not implemented in CS 1332) the tests that I copied from Homework 9 are not yet functional with my code. The character comparisons need to be adapted for when the good suffix heuristic allows for a larger shift than the bad character rule indicates.

"BoyerMoore.java" is the heart of this project. Within the BoyerMoore class there are two public methods: "BoyerMoore" and "BoyerMooreGalil." The first is an implementation of the Boyer Moore algorithm which uses both the bad character and good suffix heuristics. The second method is almost an exact replica of the former, except that it also has my current (needing testing) implementation of the Galil rule. I will now expand further on this last point.

There are two main facets of the Galil rule's implmentation. The first is determining whether or not a pattern is periodic. The second is adjusting the shift framework so that when a pattern P matches with text T we exploit P's periodicity to reduce the number of comparisons between P and T. Until today (Jan 11, 2022), I have found the pattern shift adjustment to be much easier to implement than obtaining the pattern's periodicty. (I believe that I was perhaps overthinking the pattern's periodicity/incorrectly hand-tracing examples). While the code contains JavaDocs and commenting to explain the implementation, I will give a high level overview here as well.

Before we enter the outer comparison loop I initialize the variable "l" to be equal to 0. In the inner while loop, instead of the first condition being that the pattern counter, "j," needs to be >= 0 I now impose the condition j >= l. Of course the checks are identical at first, but this follows Galil's rule: we cannot skip any comparisons until we have both found a match and determined that the pattern is periodic. 
Moving to the first if statement after the inner while loop you will see that the conditions being checked differs from the BoyerMoore method above. We first check to see if "j" is less than "l," which of course upon the first iteration of the algorithm is equal to 0. If we pass this condition then we know that the T's index "s" is the start of a match with P and that P is periodic. We can therefore set "l" to be P.length() - period and shift "s" by the period. This follows Galil's specifications.
There are two more subcomponents of this overarching shift adjustment. Quickly note that the first "else if" check is the same as the default Boyer Moore match case (1/11 note: no longer need this now that I'm fairly certain periodicity check is unnecessary...I can explain what I mean more accurately in person / over the phone). The code within the block will be run if T contains P and P is not periodic. Moving onto the else statement I want to emphasize the first inner if statement. This code is executed when three conditions have been met. The first two are simply that we have already found an instance of P within T, and P is periodic. The final condition is that since this full match, we have come across a character mismatch (recall that this character mismatch will be between P[x] and T[s + x] where x belongs to [k-m, m]). In the case of this occurrence, we must now reset our lower bound pattern index to once again be 0, as we can only exploit Galil's observation when we have found a full pattern.

Before today (1/11) I was under the impression that while k = m - ftable[m - 1] works for patterns that are periodic, it would not work (or rather lead to an incorrect answer) for patterns that were not periodic. I therefore implemented a check (namely m % k == 0) to ensure that we could use this shifting schema. However, I have since realized that using the ftable (as the CS 1332 module so graciously pointed out) works because if that pattern is not comprised of two or more exact repititions of the periodic substring (the m % k == 0 check), the manipulation of the ftable is still valid. Because I do not currently have a great way of phrasing my point, here is an example:
P = "revararev", m = 9, ftable = [0, 0, 0, 0, 1, 0, 1, 2, 3], k = 9 - 3 = 6; therefore upon matching we will check the pattern from index l = 9 - 6 = 3 to index m - 1.
T = "revararevxy"
=> match at index 0 => shift by 6 so that j = 0 is aligned with s = 6. Note that we would not check "rev," however we would check the "xy," correctly leading to a mismatch.
In other words, while "revararev" has not yet seen a full repitition of itself, "rev" is the start of its period, and we can therefore exploit Galil's heuristic somewhat.

I am looking foward to discussing this! I apologize for any spelling or grammar errors, as well as any incoherent logic.
- Quill
